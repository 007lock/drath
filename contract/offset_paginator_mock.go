// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package contract

import (
	"context"
	"sync"
)

var (
	lockOffsetPaginatorMockHasNext    sync.RWMutex
	lockOffsetPaginatorMockHasPages   sync.RWMutex
	lockOffsetPaginatorMockHasPrev    sync.RWMutex
	lockOffsetPaginatorMockNextPage   sync.RWMutex
	lockOffsetPaginatorMockNums       sync.RWMutex
	lockOffsetPaginatorMockPage       sync.RWMutex
	lockOffsetPaginatorMockPageNums   sync.RWMutex
	lockOffsetPaginatorMockPrevPage   sync.RWMutex
	lockOffsetPaginatorMockResults    sync.RWMutex
	lockOffsetPaginatorMockSetLimit   sync.RWMutex
	lockOffsetPaginatorMockSetOrderBy sync.RWMutex
	lockOffsetPaginatorMockSetPage    sync.RWMutex
)

// Ensure, that OffsetPaginatorMock does implement OffsetPaginator.
// If this is not the case, regenerate this file with moq.
var _ OffsetPaginator = &OffsetPaginatorMock{}

// OffsetPaginatorMock is a mock implementation of OffsetPaginator.
//
//     func TestSomethingThatUsesOffsetPaginator(t *testing.T) {
//
//         // make and configure a mocked OffsetPaginator
//         mockedOffsetPaginator := &OffsetPaginatorMock{
//             HasNextFunc: func() bool {
// 	               panic("mock out the HasNext method")
//             },
//             HasPagesFunc: func() bool {
// 	               panic("mock out the HasPages method")
//             },
//             HasPrevFunc: func() bool {
// 	               panic("mock out the HasPrev method")
//             },
//             NextPageFunc: func() uint64 {
// 	               panic("mock out the NextPage method")
//             },
//             NumsFunc: func() uint64 {
// 	               panic("mock out the Nums method")
//             },
//             PageFunc: func() uint64 {
// 	               panic("mock out the Page method")
//             },
//             PageNumsFunc: func() uint64 {
// 	               panic("mock out the PageNums method")
//             },
//             PrevPageFunc: func() uint64 {
// 	               panic("mock out the PrevPage method")
//             },
//             ResultsFunc: func(ctx context.Context, table string, data interface{}) error {
// 	               panic("mock out the Results method")
//             },
//             SetLimitFunc: func(limit uint64)  {
// 	               panic("mock out the SetLimit method")
//             },
//             SetOrderByFunc: func(key string, order string)  {
// 	               panic("mock out the SetOrderBy method")
//             },
//             SetPageFunc: func(page uint64)  {
// 	               panic("mock out the SetPage method")
//             },
//         }
//
//         // use mockedOffsetPaginator in code that requires OffsetPaginator
//         // and then make assertions.
//
//     }
type OffsetPaginatorMock struct {
	// HasNextFunc mocks the HasNext method.
	HasNextFunc func() bool

	// HasPagesFunc mocks the HasPages method.
	HasPagesFunc func() bool

	// HasPrevFunc mocks the HasPrev method.
	HasPrevFunc func() bool

	// NextPageFunc mocks the NextPage method.
	NextPageFunc func() uint64

	// NumsFunc mocks the Nums method.
	NumsFunc func() uint64

	// PageFunc mocks the Page method.
	PageFunc func() uint64

	// PageNumsFunc mocks the PageNums method.
	PageNumsFunc func() uint64

	// PrevPageFunc mocks the PrevPage method.
	PrevPageFunc func() uint64

	// ResultsFunc mocks the Results method.
	ResultsFunc func(ctx context.Context, table string, data interface{}) error

	// SetLimitFunc mocks the SetLimit method.
	SetLimitFunc func(limit uint64)

	// SetOrderByFunc mocks the SetOrderBy method.
	SetOrderByFunc func(key string, order string)

	// SetPageFunc mocks the SetPage method.
	SetPageFunc func(page uint64)

	// calls tracks calls to the methods.
	calls struct {
		// HasNext holds details about calls to the HasNext method.
		HasNext []struct {
		}
		// HasPages holds details about calls to the HasPages method.
		HasPages []struct {
		}
		// HasPrev holds details about calls to the HasPrev method.
		HasPrev []struct {
		}
		// NextPage holds details about calls to the NextPage method.
		NextPage []struct {
		}
		// Nums holds details about calls to the Nums method.
		Nums []struct {
		}
		// Page holds details about calls to the Page method.
		Page []struct {
		}
		// PageNums holds details about calls to the PageNums method.
		PageNums []struct {
		}
		// PrevPage holds details about calls to the PrevPage method.
		PrevPage []struct {
		}
		// Results holds details about calls to the Results method.
		Results []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Table is the table argument value.
			Table string
			// Data is the data argument value.
			Data interface{}
		}
		// SetLimit holds details about calls to the SetLimit method.
		SetLimit []struct {
			// Limit is the limit argument value.
			Limit uint64
		}
		// SetOrderBy holds details about calls to the SetOrderBy method.
		SetOrderBy []struct {
			// Key is the key argument value.
			Key string
			// Order is the order argument value.
			Order string
		}
		// SetPage holds details about calls to the SetPage method.
		SetPage []struct {
			// Page is the page argument value.
			Page uint64
		}
	}
}

// HasNext calls HasNextFunc.
func (mock *OffsetPaginatorMock) HasNext() bool {
	if mock.HasNextFunc == nil {
		panic("OffsetPaginatorMock.HasNextFunc: method is nil but OffsetPaginator.HasNext was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockHasNext.Lock()
	mock.calls.HasNext = append(mock.calls.HasNext, callInfo)
	lockOffsetPaginatorMockHasNext.Unlock()
	return mock.HasNextFunc()
}

// HasNextCalls gets all the calls that were made to HasNext.
// Check the length with:
//     len(mockedOffsetPaginator.HasNextCalls())
func (mock *OffsetPaginatorMock) HasNextCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockHasNext.RLock()
	calls = mock.calls.HasNext
	lockOffsetPaginatorMockHasNext.RUnlock()
	return calls
}

// HasPages calls HasPagesFunc.
func (mock *OffsetPaginatorMock) HasPages() bool {
	if mock.HasPagesFunc == nil {
		panic("OffsetPaginatorMock.HasPagesFunc: method is nil but OffsetPaginator.HasPages was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockHasPages.Lock()
	mock.calls.HasPages = append(mock.calls.HasPages, callInfo)
	lockOffsetPaginatorMockHasPages.Unlock()
	return mock.HasPagesFunc()
}

// HasPagesCalls gets all the calls that were made to HasPages.
// Check the length with:
//     len(mockedOffsetPaginator.HasPagesCalls())
func (mock *OffsetPaginatorMock) HasPagesCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockHasPages.RLock()
	calls = mock.calls.HasPages
	lockOffsetPaginatorMockHasPages.RUnlock()
	return calls
}

// HasPrev calls HasPrevFunc.
func (mock *OffsetPaginatorMock) HasPrev() bool {
	if mock.HasPrevFunc == nil {
		panic("OffsetPaginatorMock.HasPrevFunc: method is nil but OffsetPaginator.HasPrev was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockHasPrev.Lock()
	mock.calls.HasPrev = append(mock.calls.HasPrev, callInfo)
	lockOffsetPaginatorMockHasPrev.Unlock()
	return mock.HasPrevFunc()
}

// HasPrevCalls gets all the calls that were made to HasPrev.
// Check the length with:
//     len(mockedOffsetPaginator.HasPrevCalls())
func (mock *OffsetPaginatorMock) HasPrevCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockHasPrev.RLock()
	calls = mock.calls.HasPrev
	lockOffsetPaginatorMockHasPrev.RUnlock()
	return calls
}

// NextPage calls NextPageFunc.
func (mock *OffsetPaginatorMock) NextPage() uint64 {
	if mock.NextPageFunc == nil {
		panic("OffsetPaginatorMock.NextPageFunc: method is nil but OffsetPaginator.NextPage was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockNextPage.Lock()
	mock.calls.NextPage = append(mock.calls.NextPage, callInfo)
	lockOffsetPaginatorMockNextPage.Unlock()
	return mock.NextPageFunc()
}

// NextPageCalls gets all the calls that were made to NextPage.
// Check the length with:
//     len(mockedOffsetPaginator.NextPageCalls())
func (mock *OffsetPaginatorMock) NextPageCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockNextPage.RLock()
	calls = mock.calls.NextPage
	lockOffsetPaginatorMockNextPage.RUnlock()
	return calls
}

// Nums calls NumsFunc.
func (mock *OffsetPaginatorMock) Nums() uint64 {
	if mock.NumsFunc == nil {
		panic("OffsetPaginatorMock.NumsFunc: method is nil but OffsetPaginator.Nums was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockNums.Lock()
	mock.calls.Nums = append(mock.calls.Nums, callInfo)
	lockOffsetPaginatorMockNums.Unlock()
	return mock.NumsFunc()
}

// NumsCalls gets all the calls that were made to Nums.
// Check the length with:
//     len(mockedOffsetPaginator.NumsCalls())
func (mock *OffsetPaginatorMock) NumsCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockNums.RLock()
	calls = mock.calls.Nums
	lockOffsetPaginatorMockNums.RUnlock()
	return calls
}

// Page calls PageFunc.
func (mock *OffsetPaginatorMock) Page() uint64 {
	if mock.PageFunc == nil {
		panic("OffsetPaginatorMock.PageFunc: method is nil but OffsetPaginator.Page was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockPage.Lock()
	mock.calls.Page = append(mock.calls.Page, callInfo)
	lockOffsetPaginatorMockPage.Unlock()
	return mock.PageFunc()
}

// PageCalls gets all the calls that were made to Page.
// Check the length with:
//     len(mockedOffsetPaginator.PageCalls())
func (mock *OffsetPaginatorMock) PageCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockPage.RLock()
	calls = mock.calls.Page
	lockOffsetPaginatorMockPage.RUnlock()
	return calls
}

// PageNums calls PageNumsFunc.
func (mock *OffsetPaginatorMock) PageNums() uint64 {
	if mock.PageNumsFunc == nil {
		panic("OffsetPaginatorMock.PageNumsFunc: method is nil but OffsetPaginator.PageNums was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockPageNums.Lock()
	mock.calls.PageNums = append(mock.calls.PageNums, callInfo)
	lockOffsetPaginatorMockPageNums.Unlock()
	return mock.PageNumsFunc()
}

// PageNumsCalls gets all the calls that were made to PageNums.
// Check the length with:
//     len(mockedOffsetPaginator.PageNumsCalls())
func (mock *OffsetPaginatorMock) PageNumsCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockPageNums.RLock()
	calls = mock.calls.PageNums
	lockOffsetPaginatorMockPageNums.RUnlock()
	return calls
}

// PrevPage calls PrevPageFunc.
func (mock *OffsetPaginatorMock) PrevPage() uint64 {
	if mock.PrevPageFunc == nil {
		panic("OffsetPaginatorMock.PrevPageFunc: method is nil but OffsetPaginator.PrevPage was just called")
	}
	callInfo := struct {
	}{}
	lockOffsetPaginatorMockPrevPage.Lock()
	mock.calls.PrevPage = append(mock.calls.PrevPage, callInfo)
	lockOffsetPaginatorMockPrevPage.Unlock()
	return mock.PrevPageFunc()
}

// PrevPageCalls gets all the calls that were made to PrevPage.
// Check the length with:
//     len(mockedOffsetPaginator.PrevPageCalls())
func (mock *OffsetPaginatorMock) PrevPageCalls() []struct {
} {
	var calls []struct {
	}
	lockOffsetPaginatorMockPrevPage.RLock()
	calls = mock.calls.PrevPage
	lockOffsetPaginatorMockPrevPage.RUnlock()
	return calls
}

// Results calls ResultsFunc.
func (mock *OffsetPaginatorMock) Results(ctx context.Context, table string, data interface{}) error {
	if mock.ResultsFunc == nil {
		panic("OffsetPaginatorMock.ResultsFunc: method is nil but OffsetPaginator.Results was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Table string
		Data  interface{}
	}{
		Ctx:   ctx,
		Table: table,
		Data:  data,
	}
	lockOffsetPaginatorMockResults.Lock()
	mock.calls.Results = append(mock.calls.Results, callInfo)
	lockOffsetPaginatorMockResults.Unlock()
	return mock.ResultsFunc(ctx, table, data)
}

// ResultsCalls gets all the calls that were made to Results.
// Check the length with:
//     len(mockedOffsetPaginator.ResultsCalls())
func (mock *OffsetPaginatorMock) ResultsCalls() []struct {
	Ctx   context.Context
	Table string
	Data  interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Table string
		Data  interface{}
	}
	lockOffsetPaginatorMockResults.RLock()
	calls = mock.calls.Results
	lockOffsetPaginatorMockResults.RUnlock()
	return calls
}

// SetLimit calls SetLimitFunc.
func (mock *OffsetPaginatorMock) SetLimit(limit uint64) {
	if mock.SetLimitFunc == nil {
		panic("OffsetPaginatorMock.SetLimitFunc: method is nil but OffsetPaginator.SetLimit was just called")
	}
	callInfo := struct {
		Limit uint64
	}{
		Limit: limit,
	}
	lockOffsetPaginatorMockSetLimit.Lock()
	mock.calls.SetLimit = append(mock.calls.SetLimit, callInfo)
	lockOffsetPaginatorMockSetLimit.Unlock()
	mock.SetLimitFunc(limit)
}

// SetLimitCalls gets all the calls that were made to SetLimit.
// Check the length with:
//     len(mockedOffsetPaginator.SetLimitCalls())
func (mock *OffsetPaginatorMock) SetLimitCalls() []struct {
	Limit uint64
} {
	var calls []struct {
		Limit uint64
	}
	lockOffsetPaginatorMockSetLimit.RLock()
	calls = mock.calls.SetLimit
	lockOffsetPaginatorMockSetLimit.RUnlock()
	return calls
}

// SetOrderBy calls SetOrderByFunc.
func (mock *OffsetPaginatorMock) SetOrderBy(key string, order string) {
	if mock.SetOrderByFunc == nil {
		panic("OffsetPaginatorMock.SetOrderByFunc: method is nil but OffsetPaginator.SetOrderBy was just called")
	}
	callInfo := struct {
		Key   string
		Order string
	}{
		Key:   key,
		Order: order,
	}
	lockOffsetPaginatorMockSetOrderBy.Lock()
	mock.calls.SetOrderBy = append(mock.calls.SetOrderBy, callInfo)
	lockOffsetPaginatorMockSetOrderBy.Unlock()
	mock.SetOrderByFunc(key, order)
}

// SetOrderByCalls gets all the calls that were made to SetOrderBy.
// Check the length with:
//     len(mockedOffsetPaginator.SetOrderByCalls())
func (mock *OffsetPaginatorMock) SetOrderByCalls() []struct {
	Key   string
	Order string
} {
	var calls []struct {
		Key   string
		Order string
	}
	lockOffsetPaginatorMockSetOrderBy.RLock()
	calls = mock.calls.SetOrderBy
	lockOffsetPaginatorMockSetOrderBy.RUnlock()
	return calls
}

// SetPage calls SetPageFunc.
func (mock *OffsetPaginatorMock) SetPage(page uint64) {
	if mock.SetPageFunc == nil {
		panic("OffsetPaginatorMock.SetPageFunc: method is nil but OffsetPaginator.SetPage was just called")
	}
	callInfo := struct {
		Page uint64
	}{
		Page: page,
	}
	lockOffsetPaginatorMockSetPage.Lock()
	mock.calls.SetPage = append(mock.calls.SetPage, callInfo)
	lockOffsetPaginatorMockSetPage.Unlock()
	mock.SetPageFunc(page)
}

// SetPageCalls gets all the calls that were made to SetPage.
// Check the length with:
//     len(mockedOffsetPaginator.SetPageCalls())
func (mock *OffsetPaginatorMock) SetPageCalls() []struct {
	Page uint64
} {
	var calls []struct {
		Page uint64
	}
	lockOffsetPaginatorMockSetPage.RLock()
	calls = mock.calls.SetPage
	lockOffsetPaginatorMockSetPage.RUnlock()
	return calls
}
