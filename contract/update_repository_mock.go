// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package contract

import (
	"context"
	"sync"
)

var (
	lockUpdateRepositoryMockAttach           sync.RWMutex
	lockUpdateRepositoryMockDelete           sync.RWMutex
	lockUpdateRepositoryMockDeleteByCriteria sync.RWMutex
	lockUpdateRepositoryMockDettach          sync.RWMutex
	lockUpdateRepositoryMockDettachAll       sync.RWMutex
	lockUpdateRepositoryMockUpdate           sync.RWMutex
	lockUpdateRepositoryMockUpdateByCriteria sync.RWMutex
)

// Ensure, that UpdateRepositoryMock does implement UpdateRepository.
// If this is not the case, regenerate this file with moq.
var _ UpdateRepository = &UpdateRepositoryMock{}

// UpdateRepositoryMock is a mock implementation of UpdateRepository.
//
//     func TestSomethingThatUsesUpdateRepository(t *testing.T) {
//
//         // make and configure a mocked UpdateRepository
//         mockedUpdateRepository := &UpdateRepositoryMock{
//             AttachFunc: func(c context.Context, associated interface{}, relation string, entities interface{}) error {
// 	               panic("mock out the Attach method")
//             },
//             DeleteFunc: func(c context.Context, table string, item interface{}, relations ...string) error {
// 	               panic("mock out the Delete method")
//             },
//             DeleteByCriteriaFunc: func(c context.Context, table string, item interface{}, crit *RepoCriterias, relations ...string) error {
// 	               panic("mock out the DeleteByCriteria method")
//             },
//             DettachFunc: func(c context.Context, associated interface{}, relation string, entities interface{}) error {
// 	               panic("mock out the Dettach method")
//             },
//             DettachAllFunc: func(c context.Context, associated interface{}, relation string) error {
// 	               panic("mock out the DettachAll method")
//             },
//             UpdateFunc: func(c context.Context, table string, item interface{}) error {
// 	               panic("mock out the Update method")
//             },
//             UpdateByCriteriaFunc: func(c context.Context, table string, item interface{}, crit *RepoCriterias) error {
// 	               panic("mock out the UpdateByCriteria method")
//             },
//         }
//
//         // use mockedUpdateRepository in code that requires UpdateRepository
//         // and then make assertions.
//
//     }
type UpdateRepositoryMock struct {
	// AttachFunc mocks the Attach method.
	AttachFunc func(c context.Context, associated interface{}, relation string, entities interface{}) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(c context.Context, table string, item interface{}, relations ...string) error

	// DeleteByCriteriaFunc mocks the DeleteByCriteria method.
	DeleteByCriteriaFunc func(c context.Context, table string, item interface{}, crit *RepoCriterias, relations ...string) error

	// DettachFunc mocks the Dettach method.
	DettachFunc func(c context.Context, associated interface{}, relation string, entities interface{}) error

	// DettachAllFunc mocks the DettachAll method.
	DettachAllFunc func(c context.Context, associated interface{}, relation string) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(c context.Context, table string, item interface{}) error

	// UpdateByCriteriaFunc mocks the UpdateByCriteria method.
	UpdateByCriteriaFunc func(c context.Context, table string, item interface{}, crit *RepoCriterias) error

	// calls tracks calls to the methods.
	calls struct {
		// Attach holds details about calls to the Attach method.
		Attach []struct {
			// C is the c argument value.
			C context.Context
			// Associated is the associated argument value.
			Associated interface{}
			// Relation is the relation argument value.
			Relation string
			// Entities is the entities argument value.
			Entities interface{}
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// C is the c argument value.
			C context.Context
			// Table is the table argument value.
			Table string
			// Item is the item argument value.
			Item interface{}
			// Relations is the relations argument value.
			Relations []string
		}
		// DeleteByCriteria holds details about calls to the DeleteByCriteria method.
		DeleteByCriteria []struct {
			// C is the c argument value.
			C context.Context
			// Table is the table argument value.
			Table string
			// Item is the item argument value.
			Item interface{}
			// Crit is the crit argument value.
			Crit *RepoCriterias
			// Relations is the relations argument value.
			Relations []string
		}
		// Dettach holds details about calls to the Dettach method.
		Dettach []struct {
			// C is the c argument value.
			C context.Context
			// Associated is the associated argument value.
			Associated interface{}
			// Relation is the relation argument value.
			Relation string
			// Entities is the entities argument value.
			Entities interface{}
		}
		// DettachAll holds details about calls to the DettachAll method.
		DettachAll []struct {
			// C is the c argument value.
			C context.Context
			// Associated is the associated argument value.
			Associated interface{}
			// Relation is the relation argument value.
			Relation string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// C is the c argument value.
			C context.Context
			// Table is the table argument value.
			Table string
			// Item is the item argument value.
			Item interface{}
		}
		// UpdateByCriteria holds details about calls to the UpdateByCriteria method.
		UpdateByCriteria []struct {
			// C is the c argument value.
			C context.Context
			// Table is the table argument value.
			Table string
			// Item is the item argument value.
			Item interface{}
			// Crit is the crit argument value.
			Crit *RepoCriterias
		}
	}
}

// Attach calls AttachFunc.
func (mock *UpdateRepositoryMock) Attach(c context.Context, associated interface{}, relation string, entities interface{}) error {
	if mock.AttachFunc == nil {
		panic("UpdateRepositoryMock.AttachFunc: method is nil but UpdateRepository.Attach was just called")
	}
	callInfo := struct {
		C          context.Context
		Associated interface{}
		Relation   string
		Entities   interface{}
	}{
		C:          c,
		Associated: associated,
		Relation:   relation,
		Entities:   entities,
	}
	lockUpdateRepositoryMockAttach.Lock()
	mock.calls.Attach = append(mock.calls.Attach, callInfo)
	lockUpdateRepositoryMockAttach.Unlock()
	return mock.AttachFunc(c, associated, relation, entities)
}

// AttachCalls gets all the calls that were made to Attach.
// Check the length with:
//     len(mockedUpdateRepository.AttachCalls())
func (mock *UpdateRepositoryMock) AttachCalls() []struct {
	C          context.Context
	Associated interface{}
	Relation   string
	Entities   interface{}
} {
	var calls []struct {
		C          context.Context
		Associated interface{}
		Relation   string
		Entities   interface{}
	}
	lockUpdateRepositoryMockAttach.RLock()
	calls = mock.calls.Attach
	lockUpdateRepositoryMockAttach.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *UpdateRepositoryMock) Delete(c context.Context, table string, item interface{}, relations ...string) error {
	if mock.DeleteFunc == nil {
		panic("UpdateRepositoryMock.DeleteFunc: method is nil but UpdateRepository.Delete was just called")
	}
	callInfo := struct {
		C         context.Context
		Table     string
		Item      interface{}
		Relations []string
	}{
		C:         c,
		Table:     table,
		Item:      item,
		Relations: relations,
	}
	lockUpdateRepositoryMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockUpdateRepositoryMockDelete.Unlock()
	return mock.DeleteFunc(c, table, item, relations...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedUpdateRepository.DeleteCalls())
func (mock *UpdateRepositoryMock) DeleteCalls() []struct {
	C         context.Context
	Table     string
	Item      interface{}
	Relations []string
} {
	var calls []struct {
		C         context.Context
		Table     string
		Item      interface{}
		Relations []string
	}
	lockUpdateRepositoryMockDelete.RLock()
	calls = mock.calls.Delete
	lockUpdateRepositoryMockDelete.RUnlock()
	return calls
}

// DeleteByCriteria calls DeleteByCriteriaFunc.
func (mock *UpdateRepositoryMock) DeleteByCriteria(c context.Context, table string, item interface{}, crit *RepoCriterias, relations ...string) error {
	if mock.DeleteByCriteriaFunc == nil {
		panic("UpdateRepositoryMock.DeleteByCriteriaFunc: method is nil but UpdateRepository.DeleteByCriteria was just called")
	}
	callInfo := struct {
		C         context.Context
		Table     string
		Item      interface{}
		Crit      *RepoCriterias
		Relations []string
	}{
		C:         c,
		Table:     table,
		Item:      item,
		Crit:      crit,
		Relations: relations,
	}
	lockUpdateRepositoryMockDeleteByCriteria.Lock()
	mock.calls.DeleteByCriteria = append(mock.calls.DeleteByCriteria, callInfo)
	lockUpdateRepositoryMockDeleteByCriteria.Unlock()
	return mock.DeleteByCriteriaFunc(c, table, item, crit, relations...)
}

// DeleteByCriteriaCalls gets all the calls that were made to DeleteByCriteria.
// Check the length with:
//     len(mockedUpdateRepository.DeleteByCriteriaCalls())
func (mock *UpdateRepositoryMock) DeleteByCriteriaCalls() []struct {
	C         context.Context
	Table     string
	Item      interface{}
	Crit      *RepoCriterias
	Relations []string
} {
	var calls []struct {
		C         context.Context
		Table     string
		Item      interface{}
		Crit      *RepoCriterias
		Relations []string
	}
	lockUpdateRepositoryMockDeleteByCriteria.RLock()
	calls = mock.calls.DeleteByCriteria
	lockUpdateRepositoryMockDeleteByCriteria.RUnlock()
	return calls
}

// Dettach calls DettachFunc.
func (mock *UpdateRepositoryMock) Dettach(c context.Context, associated interface{}, relation string, entities interface{}) error {
	if mock.DettachFunc == nil {
		panic("UpdateRepositoryMock.DettachFunc: method is nil but UpdateRepository.Dettach was just called")
	}
	callInfo := struct {
		C          context.Context
		Associated interface{}
		Relation   string
		Entities   interface{}
	}{
		C:          c,
		Associated: associated,
		Relation:   relation,
		Entities:   entities,
	}
	lockUpdateRepositoryMockDettach.Lock()
	mock.calls.Dettach = append(mock.calls.Dettach, callInfo)
	lockUpdateRepositoryMockDettach.Unlock()
	return mock.DettachFunc(c, associated, relation, entities)
}

// DettachCalls gets all the calls that were made to Dettach.
// Check the length with:
//     len(mockedUpdateRepository.DettachCalls())
func (mock *UpdateRepositoryMock) DettachCalls() []struct {
	C          context.Context
	Associated interface{}
	Relation   string
	Entities   interface{}
} {
	var calls []struct {
		C          context.Context
		Associated interface{}
		Relation   string
		Entities   interface{}
	}
	lockUpdateRepositoryMockDettach.RLock()
	calls = mock.calls.Dettach
	lockUpdateRepositoryMockDettach.RUnlock()
	return calls
}

// DettachAll calls DettachAllFunc.
func (mock *UpdateRepositoryMock) DettachAll(c context.Context, associated interface{}, relation string) error {
	if mock.DettachAllFunc == nil {
		panic("UpdateRepositoryMock.DettachAllFunc: method is nil but UpdateRepository.DettachAll was just called")
	}
	callInfo := struct {
		C          context.Context
		Associated interface{}
		Relation   string
	}{
		C:          c,
		Associated: associated,
		Relation:   relation,
	}
	lockUpdateRepositoryMockDettachAll.Lock()
	mock.calls.DettachAll = append(mock.calls.DettachAll, callInfo)
	lockUpdateRepositoryMockDettachAll.Unlock()
	return mock.DettachAllFunc(c, associated, relation)
}

// DettachAllCalls gets all the calls that were made to DettachAll.
// Check the length with:
//     len(mockedUpdateRepository.DettachAllCalls())
func (mock *UpdateRepositoryMock) DettachAllCalls() []struct {
	C          context.Context
	Associated interface{}
	Relation   string
} {
	var calls []struct {
		C          context.Context
		Associated interface{}
		Relation   string
	}
	lockUpdateRepositoryMockDettachAll.RLock()
	calls = mock.calls.DettachAll
	lockUpdateRepositoryMockDettachAll.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *UpdateRepositoryMock) Update(c context.Context, table string, item interface{}) error {
	if mock.UpdateFunc == nil {
		panic("UpdateRepositoryMock.UpdateFunc: method is nil but UpdateRepository.Update was just called")
	}
	callInfo := struct {
		C     context.Context
		Table string
		Item  interface{}
	}{
		C:     c,
		Table: table,
		Item:  item,
	}
	lockUpdateRepositoryMockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	lockUpdateRepositoryMockUpdate.Unlock()
	return mock.UpdateFunc(c, table, item)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedUpdateRepository.UpdateCalls())
func (mock *UpdateRepositoryMock) UpdateCalls() []struct {
	C     context.Context
	Table string
	Item  interface{}
} {
	var calls []struct {
		C     context.Context
		Table string
		Item  interface{}
	}
	lockUpdateRepositoryMockUpdate.RLock()
	calls = mock.calls.Update
	lockUpdateRepositoryMockUpdate.RUnlock()
	return calls
}

// UpdateByCriteria calls UpdateByCriteriaFunc.
func (mock *UpdateRepositoryMock) UpdateByCriteria(c context.Context, table string, item interface{}, crit *RepoCriterias) error {
	if mock.UpdateByCriteriaFunc == nil {
		panic("UpdateRepositoryMock.UpdateByCriteriaFunc: method is nil but UpdateRepository.UpdateByCriteria was just called")
	}
	callInfo := struct {
		C     context.Context
		Table string
		Item  interface{}
		Crit  *RepoCriterias
	}{
		C:     c,
		Table: table,
		Item:  item,
		Crit:  crit,
	}
	lockUpdateRepositoryMockUpdateByCriteria.Lock()
	mock.calls.UpdateByCriteria = append(mock.calls.UpdateByCriteria, callInfo)
	lockUpdateRepositoryMockUpdateByCriteria.Unlock()
	return mock.UpdateByCriteriaFunc(c, table, item, crit)
}

// UpdateByCriteriaCalls gets all the calls that were made to UpdateByCriteria.
// Check the length with:
//     len(mockedUpdateRepository.UpdateByCriteriaCalls())
func (mock *UpdateRepositoryMock) UpdateByCriteriaCalls() []struct {
	C     context.Context
	Table string
	Item  interface{}
	Crit  *RepoCriterias
} {
	var calls []struct {
		C     context.Context
		Table string
		Item  interface{}
		Crit  *RepoCriterias
	}
	lockUpdateRepositoryMockUpdateByCriteria.RLock()
	calls = mock.calls.UpdateByCriteria
	lockUpdateRepositoryMockUpdateByCriteria.RUnlock()
	return calls
}
