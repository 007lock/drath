// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package contract

import (
	"context"
	"sync"
)

var (
	lockInsertRepositoryMockStore         sync.RWMutex
	lockInsertRepositoryMockStoreOrUpdate sync.RWMutex
)

// Ensure, that InsertRepositoryMock does implement InsertRepository.
// If this is not the case, regenerate this file with moq.
var _ InsertRepository = &InsertRepositoryMock{}

// InsertRepositoryMock is a mock implementation of InsertRepository.
//
//     func TestSomethingThatUsesInsertRepository(t *testing.T) {
//
//         // make and configure a mocked InsertRepository
//         mockedInsertRepository := &InsertRepositoryMock{
//             StoreFunc: func(c context.Context, table string, item interface{}) error {
// 	               panic("mock out the Store method")
//             },
//             StoreOrUpdateFunc: func(c context.Context, table string, item interface{}) error {
// 	               panic("mock out the StoreOrUpdate method")
//             },
//         }
//
//         // use mockedInsertRepository in code that requires InsertRepository
//         // and then make assertions.
//
//     }
type InsertRepositoryMock struct {
	// StoreFunc mocks the Store method.
	StoreFunc func(c context.Context, table string, item interface{}) error

	// StoreOrUpdateFunc mocks the StoreOrUpdate method.
	StoreOrUpdateFunc func(c context.Context, table string, item interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Store holds details about calls to the Store method.
		Store []struct {
			// C is the c argument value.
			C context.Context
			// Table is the table argument value.
			Table string
			// Item is the item argument value.
			Item interface{}
		}
		// StoreOrUpdate holds details about calls to the StoreOrUpdate method.
		StoreOrUpdate []struct {
			// C is the c argument value.
			C context.Context
			// Table is the table argument value.
			Table string
			// Item is the item argument value.
			Item interface{}
		}
	}
}

// Store calls StoreFunc.
func (mock *InsertRepositoryMock) Store(c context.Context, table string, item interface{}) error {
	if mock.StoreFunc == nil {
		panic("InsertRepositoryMock.StoreFunc: method is nil but InsertRepository.Store was just called")
	}
	callInfo := struct {
		C     context.Context
		Table string
		Item  interface{}
	}{
		C:     c,
		Table: table,
		Item:  item,
	}
	lockInsertRepositoryMockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	lockInsertRepositoryMockStore.Unlock()
	return mock.StoreFunc(c, table, item)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedInsertRepository.StoreCalls())
func (mock *InsertRepositoryMock) StoreCalls() []struct {
	C     context.Context
	Table string
	Item  interface{}
} {
	var calls []struct {
		C     context.Context
		Table string
		Item  interface{}
	}
	lockInsertRepositoryMockStore.RLock()
	calls = mock.calls.Store
	lockInsertRepositoryMockStore.RUnlock()
	return calls
}

// StoreOrUpdate calls StoreOrUpdateFunc.
func (mock *InsertRepositoryMock) StoreOrUpdate(c context.Context, table string, item interface{}) error {
	if mock.StoreOrUpdateFunc == nil {
		panic("InsertRepositoryMock.StoreOrUpdateFunc: method is nil but InsertRepository.StoreOrUpdate was just called")
	}
	callInfo := struct {
		C     context.Context
		Table string
		Item  interface{}
	}{
		C:     c,
		Table: table,
		Item:  item,
	}
	lockInsertRepositoryMockStoreOrUpdate.Lock()
	mock.calls.StoreOrUpdate = append(mock.calls.StoreOrUpdate, callInfo)
	lockInsertRepositoryMockStoreOrUpdate.Unlock()
	return mock.StoreOrUpdateFunc(c, table, item)
}

// StoreOrUpdateCalls gets all the calls that were made to StoreOrUpdate.
// Check the length with:
//     len(mockedInsertRepository.StoreOrUpdateCalls())
func (mock *InsertRepositoryMock) StoreOrUpdateCalls() []struct {
	C     context.Context
	Table string
	Item  interface{}
} {
	var calls []struct {
		C     context.Context
		Table string
		Item  interface{}
	}
	lockInsertRepositoryMockStoreOrUpdate.RLock()
	calls = mock.calls.StoreOrUpdate
	lockInsertRepositoryMockStoreOrUpdate.RUnlock()
	return calls
}
